#!/usr/bin/env perl

# <- Leading comments are for documentation only
#
# #===================
# Project: Foo
# #===================
#
# Start date
#   - What was done
#   - Another task
# End date
#
# Thu Jan  7 15:00:00 PST 2021
#   - Yet another task
# Thu Jan  7 15:51:23 PST 2021
#
# ...

use strict;
use warnings;
use Data::Dumper::Compact qw(ddc);
use DateTime::Format::Natural;
use Getopt::Long qw(GetOptions);
use Path::Tiny qw(path);
use Pod::Usage qw(pod2usage);
use Time::Piece;

pod2usage(1) unless @ARGV;

my $t = localtime;

my %opts = (
    log => './work-log-' . $t->year . sprintf('%02d', $t->mon) . '.txt',
);
GetOptions(
    \%opts, 
    'log=s',
    'help|?',
    'man',
    'verbose!',
) or pod2usage(2);
#use Data::Dumper::Concise;warn Dumper\%opts;exit;

pod2usage(1) if $opts{help};
pod2usage(-exitval => 0, -verbose => 2) if $opts{man};

my %projects;
my $project;
my $datetime;

my $parser = DateTime::Format::Natural->new;

$opts{log} = path($opts{log});

open my $fh, '<', $opts{log} or die "Can't read $opts{log}: $!";

while (my $line = readline($fh)) {
    next if $line =~ /^#/;
    chomp $line;
    next unless $line;

    if ($line =~ /^Project: (.+)$/) {
        $project = $1;
    }
    elsif ($line =~ /^([A-Z].+)$/) {
        my @parts = split /\s+/, $line;

        my $dt = $parser->parse_datetime("$parts[1] $parts[2], $parts[5] $parts[3]");
        if ($datetime) {
            my $minutes = ($dt->epoch - $datetime->epoch) / 60;
            $projects{$project} += $minutes;
            $datetime = '';
        }
        else {
            $datetime = $dt;
        }
    }
}
#warn(__PACKAGE__,' ',__LINE__," MARK: ",ddc(\%projects));

close $fh or die "Can't close $opts{log}: $!";

my $i = 0;

for $project (sort keys %projects) {
    $i++;
    printf "%d. %s: %.2f hours\n", $i, $project, $projects{$project} / 60;
}

__END__

=head1 NAME worklog

=head1 SYNOPSIS

  perl worklog --log=~/client/work-log-202101.txt

=head1 DESCRIPTION

Log your work!

=cut
