#!/usr/bin/env perl
use strict;
use warnings;

use Data::Dumper::Compact qw(ddc);
use DateTime::Format::Natural;
use File::Basename qw(dirname);
use Getopt::Long qw(GetOptions);
use Path::Tiny qw(path);
use Pod::Usage qw(pod2usage);
use Time::Piece;

pod2usage(1) unless @ARGV;

my $t = localtime;

my %opts = (
    log     => './work-log-' . $t->year . sprintf('%02d', $t->mon) . '.txt',
    project => undef,
    start   => 0,
    stop    => 0,
    task    => undef,
    summary => 0,
);
GetOptions(
    \%opts, 
    'log=s',
    'project=s',
    'start',
    'stop',
    'task=s',
    'summary',
    'help|?',
    'man',
    'verbose!',
) or pod2usage(2);

pod2usage(1) if $opts{help};
pod2usage(-exitval => 0, -verbose => 2) if $opts{man};

# Convert ~
$opts{log} = path($opts{log});

# Create the worklog file if it doesn't exist
unless (-e $opts{log}) {
    open my $fh, '>', $opts{log} or die "Can't create $opts{log}: $!";
    my $dir = path(dirname($opts{log}))->absolute;
    print $fh "# Gene Boggs' $dir worklog\n\n";
    close $fh or die "Can't close $opts{log}: $!";
}

# Summarize project time
if ($opts{summary}) {
    my %projects;
    my $project;
    my $datetime;

    open my $fh, '<', $opts{log} or die "Can't read $opts{log}: $!";

    my $parser = DateTime::Format::Natural->new;

    my $total = 0;

    while (my $line = readline($fh)) {
        next if $line =~ /^#/;
        chomp $line;
        next unless $line;

        if ($line =~ /^Project: (.+)$/) {
            $project = $1;
        }
        elsif ($line =~ /^([A-Z].+)$/) { # Date-time line
            my @parts = split /\s+/, $line;

            my $dt = $parser->parse_datetime("$parts[1] $parts[2], $parts[4] $parts[3]");
            if ($datetime) {
                my $minutes = ($dt->epoch - $datetime->epoch) / 60;
                $projects{$project} += $minutes;
                $total += $minutes;
                $datetime = '';
            }
            else {
                $datetime = $dt;
            }
        }
    }

    close $fh or die "Can't close $opts{log}: $!";

    my $i = 0;

    for $project (sort keys %projects) {
        printf "%d. %s: %.2f hours\n", ++$i, $project, $projects{$project} / 60;
    }

    printf "Total: %.2f hours\n", $total / 60;
}
# Update log
elsif ($opts{project} || $opts{start} || $opts{stop} || $opts{task}) {
    open my $fh, '>>', $opts{log} or die "Can't append to $opts{log}: $!";

    if ($opts{project}) {
        print $fh '#' . '=' x 69, "\n";
        print $fh "Project: $opts{project}\n";
        print $fh '#' . '=' x 69, "\n\n";
    }

    if ($opts{start} || $opts{stop}) {
        print $fh scalar(localtime), "\n";
        print $fh "\n" if $opts{stop};
    }

    if ($opts{task}) {
        print $fh "  - $opts{task}\n";
    }

    print "$opts{log} updated.\n";

    close $fh or die "Can't close $opts{log}: $!";
}
else {
    warn "Nothing to process.\n";
}

__END__

=head1 NAME

worklog

=head1 SYNOPSIS

  # Workflow:
  > perl worklog --log=~/project/work-log-202101.txt --project=Foo --start --task='Fix things'
  > perl worklog --log=~/project/work-log-202101.txt --task='Fix more stuff'
  > perl worklog --log=~/project/work-log-202101.txt --stop
  > perl worklog --log=~/project/work-log-202101.txt --summary

  # Or in the project directory:
  > perl worklog --project=Foo --start --task='Fix things'
  ...

=head1 DESCRIPTION

Log your work!

  #===================
  Project: Foo
  #===================
 
  Start date
    - Fix things
    - Fix more stuff
  End date

=head1 OPTIONS

=head2 log

The work B<log> text file

If no such file exists, one is created, and named
C<work-log-YYYYMM.txt>.  If no B<log> file is given, the program
assumes it is in the current directory.

=head2 project

The B<project> to be worked

=head2 task

A B<task> within a B<project>'s B<start> and B<stop> times

=head2 start

The B<project> B<start> time

=head2 stop

The B<project> B<stop> time

=head2 summary

Summarization of each B<project>'s hourly total and a grand total

=cut
